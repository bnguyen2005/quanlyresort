<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ƒê·∫∑t ph√≤ng c·ªßa t√¥i | Resort</title>
  <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/bootstrap.min.css">
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="/css/tokens.css">
  <link rel="stylesheet" href="/css/globals.css">
  <link rel="stylesheet" href="/css/grid.css">
  <link rel="stylesheet" href="/css/components/navbar.css">
  <link rel="stylesheet" href="css/navbar-auth.css">
  <link rel="stylesheet" href="css/open-iconic-bootstrap.min.css">
  <!-- SignalR removed - using simple polling instead -->
  <!-- QRCode.js for generating QR codes from checkoutUrl -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  <style>
    body{font-family:'Poppins',sans-serif;padding-top:0;overflow-x:hidden;background:#f8f9fa}
    .ftco-navbar{position:sticky!important;top:0!important;z-index:1030!important;background-color:#1a1a1a!important;width:100%!important;margin:0!important}
    
    /* Modern Hero Section - Same as other pages */
    .rooms-hero {
      background-image: url('images/bg_1.jpg');
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
      background-repeat: no-repeat;
      padding: 140px 0 100px;
      color: #fff;
      text-align: center;
      position: relative;
      overflow: hidden;
      margin-bottom: 60px;
      min-height: 500px;
      display: flex;
      align-items: center;
    }
    .rooms-hero::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.5) 100%);
      z-index: 0;
    }
    .rooms-hero::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: url('data:image/svg+xml,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse"><path d="M 50 0 L 0 0 0 50" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
      opacity: 0.3;
      z-index: 1;
    }
    .rooms-hero-content {
      position: relative;
      z-index: 2;
      animation: slideUp 0.8s ease;
      width: 100%;
    }
    .rooms-hero h1 {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 20px;
      color: #ffffff !important;
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
      animation: fadeInDown 1s ease;
    }
    .rooms-hero p {
      font-size: 20px;
      color: #ffffff !important;
      opacity: 0.95;
      text-shadow: 0 2px 8px rgba(0,0,0,0.2);
      animation: fadeInUp 1.2s ease;
    }
    
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @media (max-width: 768px) {
      .rooms-hero {
        padding: 100px 0 60px;
        min-height: 400px;
      }
      .rooms-hero h1 {
        font-size: 32px;
      }
      .rooms-hero p {
        font-size: 16px;
      }
    }
    
    .booking-card{background:#fff;padding:30px;border-radius:20px;box-shadow:0 10px 40px rgba(0,0,0,0.1);margin-bottom:25px;transition:all 0.3s;animation:slideUp 0.6s ease forwards;opacity:0}
    .booking-card:nth-child(1){animation-delay:0.1s}
    .booking-card:nth-child(2){animation-delay:0.2s}
    .booking-card:nth-child(3){animation-delay:0.3s}
    .booking-card:hover{transform:translateY(-5px);box-shadow:0 15px 50px rgba(0,0,0,0.15)}
    
    .booking-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:20px;border-bottom:2px solid #e9ecef}
    .booking-code{font-size:24px;font-weight:700;color:#c8a97e}
    .booking-status{display:inline-block;padding:8px 20px;border-radius:20px;font-weight:600;font-size:14px}
    
    .booking-details{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:20px;margin:20px 0}
    .detail-item{padding:15px;background:#f8f9fa;border-radius:10px}
    .detail-label{font-size:12px;color:#666;text-transform:uppercase;margin-bottom:5px}
    .detail-value{font-size:18px;font-weight:600;color:#1a1a1a}
    
    .status-pending{background:#fff3cd;color:#856404}
    .status-confirmed{background:#d1ecf1;color:#0c5460}
    .status-paid{background:#d4edda;color:#155724;border:2px solid #c3e6cb}
    .status-assigned{background:#cfe2ff;color:#084298}
    .status-checkedin{background:#d1e7dd;color:#0f5132}
    .status-checkedout{background:#e2e3e5;color:#41464b}
    .status-cancelled{background:#f8d7da;color:#842029}
    
    .booking-actions{display:flex;gap:10px;margin-top:20px}
    
    /* Modal payment styling - ensure visible and scrollable */
    #payListModal .modal-dialog{
      max-height:90vh;
      margin:1.75rem auto;
      z-index:9999;
    }
    #payListModal .modal-content{
      max-height:90vh;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    #payListModal .modal-body{
      max-height:calc(90vh - 150px);
      overflow-y:auto;
      overflow-x:hidden;
      padding:30px;
    }
    #payListModal .modal-footer{
      flex-shrink:0;
      position:sticky;
      bottom:0;
      background:#fff;
      z-index:10;
      border-top:2px solid #f0f0f0;
      margin-top:auto;
    }
    #payListModal #plVqrImg{
      max-width:100%;
      width:320px;
      height:320px;
      border:4px solid #e9ecef;
      border-radius:20px;
      padding:15px;
      background:#fff;
      box-shadow:0 8px 25px rgba(0,0,0,0.15);
      object-fit:contain;
    }
    @media(max-width:768px){
      #payListModal .modal-dialog{
        max-height:95vh;
        margin:0.5rem;
      }
      #payListModal .modal-content{
        max-height:95vh;
      }
      #payListModal .modal-body{
        max-height:calc(95vh - 140px);
        padding:20px;
      }
      #payListModal #plVqrImg{
        width:280px;
        height:280px;
      }
    }
    
    @keyframes slideUp{from{opacity:0;transform:translateY(30px)}to{opacity:1;transform:translateY(0)}}
  </style>
</head>
<body>
  <!-- Header placeholder - will be loaded by load-header.js -->
  <div id="header-placeholder"></div>
  
  <!-- Load header component -->
  <script src="js/load-header.js"></script>

  <!-- Hero Section -->
  <section class="rooms-hero">
    <div class="container">
      <div class="rooms-hero-content">
        <h1>üìÖ ƒê·∫∑t ph√≤ng c·ªßa t√¥i</h1>
        <p>Xem v√† qu·∫£n l√Ω c√°c ƒë·∫∑t ph√≤ng c·ªßa b·∫°n</p>
      </div>
    </div>
  </section>

  <div class="container mb-5 mt-4">
    <div id="bookingsList">
      <div class="text-center py-5">
        <div class="spinner-border text-primary" role="status">
          <span class="sr-only">Loading...</span>
        </div>
        <p class="mt-3 text-muted">ƒêang t·∫£i danh s√°ch ƒë·∫∑t ph√≤ng...</p>
      </div>
    </div>
  </div>

  <!-- Modal Thanh to√°n (My Bookings) -->
  <div class="modal fade" id="payListModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content" style="border-radius:20px;overflow:hidden">
        <div class="modal-header" style="background:linear-gradient(135deg,#c8a97e 0%,#b89968 100%);color:#fff;border:none;padding:25px 30px">
          <h5 class="modal-title" style="font-size:24px;font-weight:700;margin:0">üí≥ Ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close" style="opacity:1"></button>
        </div>
        <div class="modal-body" style="padding:30px">
          <div class="mb-4">
            <label class="form-label" style="font-size:16px;font-weight:600;margin-bottom:12px;display:block">
              üì± Ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n
            </label>
            <select id="plPaymentMethod" class="form-select" style="min-height:56px;font-size:16px;padding:16px 45px 16px 18px;border:2px solid #e9ecef;border-radius:12px">
              <option value="BankTransfer" selected>üí≥ Chuy·ªÉn kho·∫£n qua QR (VietQR)</option>
              <option value="Cash">üíµ Thanh to√°n t·∫°i kh√°ch s·∫°n</option>
            </select>
          </div>
          
          <div id="plBankSection" class="mt-3">
            <p class="mb-4" style="font-size:16px;line-height:1.6;color:#555">
              <strong style="color:#1a1a1a;font-size:17px">Chuy·ªÉn kho·∫£n nhanh qua QR.</strong><br>
              N·ªôi dung chuy·ªÉn kho·∫£n: <code style="background:#f8f9fa;padding:8px 12px;border-radius:8px;font-size:15px;font-weight:600;color:#c8a97e">BOOKING-<span id="plCode2">#</span></code>
            </p>
            <div class="text-center mb-4">
              <img id="plVqrImg" alt="VietQR">
            </div>
            <div class="card" style="background:#f8f9fa;border:2px solid #e9ecef;border-radius:15px;padding:25px">
              <div style="font-size:16px;line-height:2">
                <div class="mb-3"><strong style="color:#1a1a1a;font-size:17px">Ng√¢n h√†ng:</strong> <span id="plBankName" style="color:#555;font-size:16px">MBBank</span></div>
                <div class="mb-3"><strong style="color:#1a1a1a;font-size:17px">STK:</strong> <span id="plBankAcc" style="color:#555;font-size:16px;font-weight:600">0901329227</span> ¬∑ <strong style="color:#1a1a1a;font-size:17px">CTK:</strong> <span id="plBankAccName" style="color:#555;font-size:16px">Resort Deluxe</span></div>
                <div class="mb-0"><strong style="color:#1a1a1a;font-size:17px">S·ªë ti·ªÅn:</strong> <span id="plAmount" style="color:#c8a97e;font-size:20px;font-weight:700">0 ‚Ç´</span></div>
              </div>
            </div>
          </div>
          
          <div id="plCashSection" class="mt-3" style="display:none">
            <div class="alert alert-info" style="padding:20px;border-radius:12px;border-left:4px solid #0dcaf0">
              <h6 style="font-weight:700;margin-bottom:10px">üíµ Thanh to√°n t·∫°i kh√°ch s·∫°n</h6>
              <p style="margin:0;font-size:15px">
                B·∫°n c√≥ th·ªÉ thanh to√°n b·∫±ng ti·ªÅn m·∫∑t ho·∫∑c th·∫ª t·∫°i qu·∫ßy l·ªÖ t√¢n khi l√†m th·ªß t·ª•c check-in.
                <br><strong>ƒê·ªãa ch·ªâ:</strong> 123 ƒê∆∞·ªùng Bi·ªÉn Xanh, Th√†nh ph·ªë Bi·ªÉn, Vi·ªát Nam
              </p>
            </div>
          </div>
        </div>
        <div class="modal-footer" style="border-top:2px solid #f0f0f0;padding:20px 30px">
          <button class="btn btn-outline-secondary" data-bs-dismiss="modal" style="padding:12px 28px;font-size:16px;font-weight:600;border-radius:10px">ƒê√≥ng</button>
          <div id="plPaymentStatus" style="text-align:center;flex:1;padding:0 20px">
            <div id="plWaitingMessage" style="display:none;color:#0dcaf0;font-weight:600;font-size:15px">
              <span class="spinner-border spinner-border-sm me-2" role="status"></span>
              <span id="plWaitingText">ƒêang ch·ªù x√°c nh·∫≠n thanh to√°n...</span>
            </div>
            <div id="plPaidMessage" style="display:none;color:#198754;font-weight:600;font-size:15px">
              <span class="oi oi-check me-2"></span>
              Thanh to√°n th√†nh c√¥ng! ƒêang c·∫≠p nh·∫≠t...
            </div>
            <div id="plFailedMessage" style="display:none;color:#dc3545;font-weight:600;font-size:15px">
              <span class="oi oi-x me-2"></span>
              Thanh to√°n th·∫•t b·∫°i
            </div>
            <div id="plExpiredMessage" style="display:none;color:#ffc107;font-weight:600;font-size:15px">
              <span class="oi oi-clock me-2"></span>
              QR ƒë√£ h·∫øt h·∫°n
            </div>
            <div id="plTimer" style="display:none;color:#6c757d;font-size:14px;margin-top:8px">
              ‚è∞ Th·ªùi gian c√≤n l·∫°i: <span id="plTimerValue">15:00</span>
            </div>
          </div>
          <!-- Test Payment Button (ch·ªâ hi·ªÉn th·ªã khi localhost ho·∫∑c development) -->
          <button id="plTestPaymentBtn" class="btn btn-warning" onclick="testPayment()" style="display:none;padding:12px 28px;font-size:14px;font-weight:600;border-radius:10px">
            üß™ Test Payment
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal Thanh To√°n ƒê∆°n Gi·∫£n -->
  <div class="modal fade" id="simplePaymentModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content" style="border-radius: 20px;">
        <div class="modal-header" style="background: linear-gradient(135deg, #c8a97e 0%, #b89968 100%); color: white;">
          <h5 class="modal-title" style="font-size: 24px; font-weight: 700;">üí≥ Thanh To√°n</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body" style="padding: 30px;">
          <div class="text-center mb-4">
            <h6>M√£ ƒë·∫∑t ph√≤ng: <strong id="spBookingCode">-</strong></h6>
            <h4 class="text-primary">S·ªë ti·ªÅn: <span id="spAmount">0 ‚Ç´</span></h4>
          </div>

          <div id="spQRSection">
            <p class="text-center mb-3">
              <strong>N·ªôi dung chuy·ªÉn kho·∫£n:</strong><br>
              <code id="spContent" style="background: #f8f9fa; padding: 8px 12px; border-radius: 8px; font-size: 16px; font-weight: 600;">BOOKING-</code>
            </p>
            <div class="text-center mb-4">
              <img id="spQRImage" alt="QR Code" style="max-width: 300px; border: 4px solid #e9ecef; border-radius: 15px; padding: 15px; display: none;">
            </div>
            <div class="card" style="background: #f8f9fa; padding: 20px; border-radius: 12px;">
              <p class="mb-2"><strong>Ng√¢n h√†ng:</strong> MBBank</p>
              <p class="mb-2"><strong>S·ªë t√†i kho·∫£n:</strong> <span id="spBankAccount">0901329227</span></p>
              <p class="mb-0"><strong>Ch·ªß t√†i kho·∫£n:</strong> <span id="spBankName">Resort Deluxe</span></p>
            </div>
          </div>

          <div id="spWaiting" class="text-center mt-4" style="display: block;">
            <div class="spinner-border text-primary" role="status"></div>
            <p class="mt-2">ƒêang ch·ªù thanh to√°n...</p>
          </div>

          <div id="spSuccess" class="text-center mt-4" style="display: none;">
            <div class="alert alert-success">
              <h5>‚úÖ Thanh to√°n th√†nh c√¥ng!</h5>
              <p>ƒêang c·∫≠p nh·∫≠t th√¥ng tin...</p>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ƒê√≥ng</button>
        </div>
      </div>
    </div>
  </div>

  <script src="js/jquery.min.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script src="js/popper.min.js"></script>
  <script src="../js/api.js"></script>
  <script src="js/navbar-auth.js"></script>
  <!-- payment-websocket.js removed - using simple-payment.js instead -->
  <script src="js/simple-payment.js"></script>
  <script>
    let customerId = null;
    // BANK_CODE, BANK_ACCOUNT, BANK_ACCOUNT_NAME are defined in simple-payment.js

    function vnd(n) {
      try {
        // IMPORTANT: VND has no minor units (no cents), so we must set minimumFractionDigits: 0
        // to prevent automatic division by 100
        return new Intl.NumberFormat('vi-VN', {
          style: 'currency', 
          currency: 'VND',
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        }).format(n || 0);
      } catch(_) {
        return (n || 0).toLocaleString('vi-VN') + ' ‚Ç´';
      }
    }

    function formatDate(dateStr) {
      if (!dateStr) return '-';
      const d = new Date(dateStr);
      return d.toLocaleDateString('vi-VN');
    }

    function getStatusClass(status) {
      const classes = {
        'Pending': 'status-pending',
        'Confirmed': 'status-confirmed',
        'Paid': 'status-paid',
        'Assigned': 'status-assigned',
        'CheckedIn': 'status-checkedin',
        'CheckedOut': 'status-checkedout',
        'Cancelled': 'status-cancelled'
      };
      return classes[status] || 'status-pending';
    }

    function getStatusText(status) {
      const texts = {
        'Pending': '‚è≥ Ch·ªù x√°c nh·∫≠n',
        'Confirmed': '‚úÖ ƒê√£ x√°c nh·∫≠n',
        'Paid': 'üí∞ ƒê√£ thanh to√°n',
        'Assigned': 'üè® ƒê√£ ph√¢n ph√≤ng',
        'CheckedIn': 'üîë ƒê√£ nh·∫≠n ph√≤ng',
        'CheckedOut': 'üëã ƒê√£ tr·∫£ ph√≤ng',
        'Cancelled': '‚ùå ƒê√£ h·ªßy'
      };
      return texts[status] || status;
    }
    
    function formatPaymentDate(dateString) {
      if (!dateString) return '-';
      try {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) return 'V·ª´a xong';
        if (diffMins < 60) return `${diffMins} ph√∫t tr∆∞·ªõc`;
        if (diffHours < 24) return `${diffHours} gi·ªù tr∆∞·ªõc`;
        if (diffDays < 7) return `${diffDays} ng√†y tr∆∞·ªõc`;
        
        return formatDate(dateString);
      } catch(e) {
        return formatDate(dateString);
      }
    }
    
    function canPayBooking(booking) {
      // Ch·ªâ cho ph√©p thanh to√°n khi booking ·ªü tr·∫°ng th√°i Pending ho·∫∑c Confirmed v√† ch∆∞a thanh to√°n
      return (booking.status === 'Pending' || booking.status === 'Confirmed') && booking.status !== 'Paid';
    }

    function escapeHtml(str){
      return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function renderSpecialRequests(special){
      if (!special) return '';
      try{
        const obj = JSON.parse(special);
        if (obj && typeof obj === 'object'){
          const map = [
            ['guestName','H·ªç t√™n'],
            ['guestEmail','Email'],
            ['guestPhone','SƒêT'],
            ['nationality','Qu·ªëc t·ªãch'],
            ['idCard','CMND/CCCD'],
            ['passport','H·ªô chi·∫øu'],
            ['address','ƒê·ªãa ch·ªâ'],
            ['arrivalTime','Gi·ªù ƒë·∫øn d·ª± ki·∫øn'],
            ['flightNumber','Chuy·∫øn bay'],
            ['paymentMethod','Thanh to√°n'],
            ['note','Ghi ch√∫']
          ];
          const rows = map
            .filter(([k]) => obj[k])
            .map(([k,label]) => `<div class="d-flex justify-content-between"><span class="text-muted">${label}</span><span class="fw-semibold">${escapeHtml(obj[k])}</span></div>`)
            .join('');
          if (rows) return `<div class="mt-3 p-3 bg-light rounded"><strong>Th√¥ng tin b·ªï sung:</strong><div class="mt-2">${rows}</div></div>`;
        }
      }catch(_){ /* not JSON */ }
      return `<div class="mt-3 p-3 bg-light rounded"><strong>Y√™u c·∫ßu ƒë·∫∑c bi·ªát:</strong><p class="mb-0">${escapeHtml(special)}</p></div>`;
    }

    function getCustomerIdFromToken(token) {
      try {
        const parts = token.split('.');
        if (parts.length >= 2) {
          const payload = JSON.parse(atob(parts[1]));
          return payload.CustomerId || payload.customerId || null;
        }
      } catch(e) {
        console.warn('Error decoding token:', e);
      }
      return null;
    }

    // Fetch booking detail for amount calculation (async, updates UI after fetch)
    async function fetchBookingDetailForAmount(bookingId, bookingObj) {
      try {
        const token = localStorage.getItem('token');
        if (!token) return;
        
        const detailUrl = `${location.origin}/api/bookings/${bookingId}?_=${Date.now()}`;
        const detailResp = await fetch(detailUrl, {
          headers: { 'Authorization': `Bearer ${token}` },
          cache: 'no-store'
        });
        
        if (detailResp.ok) {
          const detail = await detailResp.json();
          console.log(`‚úÖ [fetchBookingDetailForAmount] Fetched detail for booking ${bookingId}:`, detail);
          
          // Calculate amount from detail (same logic as payBooking)
          let amount = Number(detail.estimatedTotalAmount ?? detail.totalAmount ?? detail.amount ?? 0);
          
          // Trust backend amount - Database ƒë√£ ƒë∆∞·ª£c s·ª≠a v·ªÅ gi√° ƒë√∫ng (5,000 VND)
          // Kh√¥ng c·∫ßn correction n·ªØa
          console.log(`‚úÖ [fetchBookingDetailForAmount] Booking ${bookingId}: Using amount from backend:`, amount);
          
          if (amount <= 0 && detail.checkInDate && detail.checkOutDate) {
            const checkin = new Date(detail.checkInDate);
            const checkout = new Date(detail.checkOutDate);
            const nights = Math.ceil((checkout - checkin) / (1000 * 60 * 60 * 24));
            
            // Try multiple ways to get room price (same as payBooking)
            let roomPrice = 0;
            if (detail.room?.pricePerNight) {
              roomPrice = Number(detail.room.pricePerNight);
              console.log(`‚úÖ [fetchBookingDetailForAmount] Room price from room.pricePerNight: ${roomPrice}`);
            } else if (detail.room?.roomTypeNavigation?.pricePerNight) {
              roomPrice = Number(detail.room.roomTypeNavigation.pricePerNight);
              console.log(`‚úÖ [fetchBookingDetailForAmount] Room price from roomTypeNavigation.pricePerNight: ${roomPrice}`);
            } else if (detail.pricePerNight) {
              roomPrice = Number(detail.pricePerNight);
              console.log(`‚úÖ [fetchBookingDetailForAmount] Room price from bookingDetail.pricePerNight: ${roomPrice}`);
            } else if (detail.roomPrice) {
              roomPrice = Number(detail.roomPrice);
              console.log(`‚úÖ [fetchBookingDetailForAmount] Room price from bookingDetail.roomPrice: ${roomPrice}`);
            } else {
              // Try to fetch room by RequestedRoomType (same as payBooking)
              console.log('üîµ [fetchBookingDetailForAmount] No room price found, trying to fetch by requestedRoomType...');
              const requestedType = detail?.requestedRoomType || bookingObj?.requestedRoomType;
              if (requestedType) {
                try {
                  const roomsResp = await fetch(`${location.origin}/api/rooms?roomTypeId=${detail?.roomTypeId || ''}&_=${Date.now()}`, {
                    cache: 'no-store',
                    headers: { 'Authorization': `Bearer ${token}` }
                  });
                  if (roomsResp.ok) {
                    const rooms = await roomsResp.json();
                    const matchingRoom = Array.isArray(rooms) ? rooms.find(r => 
                      r.roomTypeName === requestedType || 
                      r.roomType === requestedType ||
                      r.typeName === requestedType
                    ) : null;
                    if (matchingRoom?.pricePerNight) {
                      roomPrice = Number(matchingRoom.pricePerNight);
                      console.log(`‚úÖ [fetchBookingDetailForAmount] Room price from API search: ${roomPrice}`);
                    }
                  }
                } catch(e) {
                  console.error('‚ùå [fetchBookingDetailForAmount] Error fetching rooms:', e);
                }
              }
            }
            
            if (nights > 0 && roomPrice > 0) {
              amount = nights * roomPrice;
              console.log(`‚úÖ [fetchBookingDetailForAmount] Calculated: ${vnd(amount)} (${nights} nights √ó ${vnd(roomPrice)})`);
            } else {
              console.warn(`‚ö†Ô∏è [fetchBookingDetailForAmount] Cannot calculate: nights=${nights}, roomPrice=${roomPrice}`);
            }
          }
          
          if (amount > 0) {
            // Update booking object
            bookingObj.estimatedTotalAmount = amount;
            console.log(`‚úÖ [fetchBookingDetailForAmount] Updated amount for booking ${bookingId}: ${vnd(amount)}`);
            
            // Update UI
            updateBookingCardAmount(bookingId, amount, detail.bookingCode);
          }
        }
      } catch(e) {
        console.error(`‚ùå [fetchBookingDetailForAmount] Error for booking ${bookingId}:`, e);
      }
    }
    
    // Fetch booking detail synchronously and return calculated amount (for initial render)
    async function fetchBookingDetailForAmountSync(bookingId, bookingObj) {
      try {
        const token = localStorage.getItem('token');
        if (!token) return 0;
        
        const detailUrl = `${location.origin}/api/bookings/${bookingId}?_=${Date.now()}`;
        const detailResp = await fetch(detailUrl, {
          headers: { 'Authorization': `Bearer ${token}` },
          cache: 'no-store'
        });
        
        if (!detailResp.ok) return 0;
        
        const detail = await detailResp.json();
        console.log(`‚úÖ [fetchBookingDetailForAmountSync] Fetched detail for booking ${bookingId}`);
        
        // Calculate amount (same logic as payBooking)
        let amount = Number(detail.estimatedTotalAmount ?? detail.totalAmount ?? detail.amount ?? 0);
        
        // Trust backend amount - Database ƒë√£ ƒë∆∞·ª£c s·ª≠a v·ªÅ gi√° ƒë√∫ng (5,000 VND)
        // Kh√¥ng c·∫ßn correction n·ªØa
        console.log(`‚úÖ [fetchBookingDetailForAmountSync] Booking ${bookingId}: Using amount from backend:`, amount);
        
        if (amount <= 0 && detail.checkInDate && detail.checkOutDate) {
          const checkin = new Date(detail.checkInDate);
          const checkout = new Date(detail.checkOutDate);
          const nights = Math.ceil((checkout - checkin) / (1000 * 60 * 60 * 24));
          
          let roomPrice = 0;
          if (detail.room?.pricePerNight) {
            roomPrice = Number(detail.room.pricePerNight);
          } else if (detail.room?.roomTypeNavigation?.pricePerNight) {
            roomPrice = Number(detail.room.roomTypeNavigation.pricePerNight);
          } else if (detail.pricePerNight) {
            roomPrice = Number(detail.pricePerNight);
          } else if (detail.roomPrice) {
            roomPrice = Number(detail.roomPrice);
          }
          
          if (nights > 0 && roomPrice > 0) {
            amount = nights * roomPrice;
          }
        }
        
        if (amount > 0) {
          bookingObj.estimatedTotalAmount = amount;
        }
        
        return amount;
      } catch(e) {
        console.error(`‚ùå [fetchBookingDetailForAmountSync] Error for booking ${bookingId}:`, e);
        return 0;
      }
    }
    
    // Update booking card amount display
    function updateBookingCardAmount(bookingId, amount, bookingCode) {
      const bookingCards = document.querySelectorAll('.booking-card');
      bookingCards.forEach((card) => {
        const codeEl = card.querySelector('.booking-code');
        if (codeEl && (codeEl.textContent.includes(`#${bookingId}`) || (bookingCode && codeEl.textContent.includes(`#${bookingCode}`)))) {
          const amountEl = card.querySelector('.detail-value.text-primary');
          if (amountEl) {
            amountEl.textContent = vnd(amount);
            console.log(`‚úÖ [updateBookingCardAmount] Updated display for booking ${bookingId}`);
          }
        }
      });
    }

    async function loadBookings() {
      try {
        const token = localStorage.getItem('token');
        const userStr = localStorage.getItem('user');
        
        if (!token || !userStr) {
          showToast('Vui l√≤ng ƒëƒÉng nh·∫≠p', 'warning');
          setTimeout(() => window.location.href = '../admin/html/login.html', 2000);
          return;
        }

        // Try to get CustomerId from token first, then from user object
        let customerIdFromToken = getCustomerIdFromToken(token);
        const user = JSON.parse(userStr);
        customerId = customerIdFromToken || user.customerId || user.userId || user.CustomerId;
        
        console.log('üîµ [loadBookings] CustomerId from token:', customerIdFromToken);
        console.log('üîµ [loadBookings] CustomerId from user:', user.customerId || user.userId || user.CustomerId);
        console.log('üîµ [loadBookings] Final CustomerId:', customerId);
        
        if (!customerId) {
          showToast('Kh√¥ng t√¨m th·∫•y th√¥ng tin kh√°ch h√†ng. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i', 'danger');
          setTimeout(() => window.location.href = '../admin/html/login.html', 2000);
          return;
        }

        showPageLoading('ƒêang t·∫£i ƒë·∫∑t ph√≤ng...');
        
        // D√πng endpoint /api/bookings/my ƒë·ªÉ l·∫•y theo JWT, tr√°nh l·ªá thu·ªôc CustomerId
        const apiUrl = `${location.origin}/api/bookings/my?_=${Date.now()}`;
        console.log('üîµ [loadBookings] Fetching:', apiUrl);
        const resp = await fetch(apiUrl, {
          cache: 'no-store',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        console.log('üîµ [loadBookings] Response status:', resp.status, resp.statusText);
        if (!resp.ok) {
          if (resp.status === 403) {
            throw new Error('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
          }
          const errorText = await resp.text();
          console.error('‚ùå [loadBookings] API Error:', errorText);
          throw new Error(errorText || 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch ƒë·∫∑t ph√≤ng');
        }

        const bookings = await resp.json();
        const bookingsArray = Array.isArray(bookings) ? bookings : [];
        
        // Try to load room types for price calculation (if not cached)
        if (!window._roomTypesCache) {
          try {
            const roomTypesResp = await fetch(`${location.origin}/api/room-types?_=${Date.now()}`, {
              cache: 'no-store',
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (roomTypesResp.ok) {
              window._roomTypesCache = await roomTypesResp.json();
              console.log('‚úÖ [loadBookings] Room types cached for price calculation');
            }
          } catch(e) {
            console.warn('‚ö†Ô∏è [loadBookings] Could not load room types:', e);
          }
        }
        
        // Check if any booking status changed to Paid (to show notification)
        const oldBookings = window._bookings || [];
        bookingsArray.forEach(newBooking => {
          const oldBooking = oldBookings.find(b => b.bookingId === newBooking.bookingId);
          if (oldBooking && oldBooking.status !== 'Paid' && newBooking.status === 'Paid') {
            console.log('‚úÖ [loadBookings] Payment detected! Booking', newBooking.bookingId, 'changed from', oldBooking.status, 'to Paid');
            showToast(`‚úÖ Thanh to√°n th√†nh c√¥ng cho ƒë·∫∑t ph√≤ng ${newBooking.bookingCode}!`, 'success');
            
            // N·∫øu modal ƒëang m·ªü cho booking n√†y, update UI
            if (currentPollingBookingId === newBooking.bookingId) {
              const paidMsg = document.getElementById('plPaidMessage');
              const qrImg = document.getElementById('plVqrImg');
              const bankSection = document.getElementById('plBankSection');
              const waitingMsg = document.getElementById('plWaitingMessage');
              
              if (paidMsg) paidMsg.style.display = 'block';
              if (waitingMsg) waitingMsg.style.display = 'none';
              if (qrImg) qrImg.style.display = 'none';
              if (bankSection) bankSection.style.display = 'none';
              
              // D·ª´ng polling (using simple-payment.js)
              if (window.paymentPollingInterval) {
                clearInterval(window.paymentPollingInterval);
                window.paymentPollingInterval = null;
              }
            }
          }
        });
        
        renderBookings(bookingsArray);
        window._bookings = bookingsArray;
        
        // After rendering, fetch booking details for bookings with amount = 0
        // This ensures all amounts are displayed correctly
        setTimeout(() => {
          bookingsArray.forEach(booking => {
            const amount = Number(booking.estimatedTotalAmount ?? booking.totalAmount ?? booking.amount ?? booking.totalPrice ?? 0);
            if (amount <= 0 && booking.bookingId) {
              console.log(`üîµ [loadBookings] Fetching detail for booking ${booking.bookingId} (amount = 0)`);
              fetchBookingDetailForAmount(booking.bookingId, booking);
            }
          });
        }, 500); // Small delay to ensure DOM is ready
        
      } catch(e) {
        console.error('Error loading bookings:', e);
        showToast('L·ªói: ' + e.message, 'danger');
        document.getElementById('bookingsList').innerHTML = `
          <div class="alert alert-warning">
            <h5>Kh√¥ng th·ªÉ t·∫£i danh s√°ch ƒë·∫∑t ph√≤ng</h5>
            <p>${e.message}</p>
          </div>
        `;
      } finally {
        hidePageLoading();
      }
    }

    function renderBookings(bookings) {
      const container = document.getElementById('bookingsList');
      
      if (!Array.isArray(bookings) || bookings.length === 0) {
        container.innerHTML = `
          <div class="text-center py-5">
            <div style="font-size:80px;margin-bottom:20px">üì≠</div>
            <h4>Ch∆∞a c√≥ ƒë·∫∑t ph√≤ng n√†o</h4>
            <p class="text-muted">B·∫Øt ƒë·∫ßu ƒë·∫∑t ph√≤ng ngay ƒë·ªÉ c√≥ nh·ªØng tr·∫£i nghi·ªám tuy·ªát v·ªùi!</p>
            <a href="rooms.html" class="btn btn-primary mt-3">ƒê·∫∑t ph√≤ng ngay</a>
          </div>
        `;
        return;
      }

      container.innerHTML = bookings.map((booking, idx) => {
        const checkin = formatDate(booking.checkInDate);
        const checkout = formatDate(booking.checkOutDate);
        const bookingDate = formatDate(booking.bookingDate || booking.createdAt);
        const nights = booking.checkInDate && booking.checkOutDate 
          ? Math.ceil((new Date(booking.checkOutDate) - new Date(booking.checkInDate)) / (1000 * 60 * 60 * 24))
          : '-';
        const specialBlock = renderSpecialRequests(booking.specialRequests);
        
        // Get amount from backend - TRUST BACKEND VALUE
        // Database ƒë√£ ƒë∆∞·ª£c s·ª≠a v·ªÅ gi√° ƒë√∫ng (5,000 VND), kh√¥ng c·∫ßn correction n·ªØa
        let amount = Number(booking.estimatedTotalAmount ?? booking.totalAmount ?? booking.amount ?? booking.totalPrice ?? 0);
        console.log(`‚úÖ [renderBookings] Booking ${booking.bookingId}: Using amount from backend:`, amount);
        
        // If amount is 0, try to calculate from room price and nights
        if (amount <= 0 && booking.checkInDate && booking.checkOutDate && nights !== '-') {
          const nightsNum = typeof nights === 'number' ? nights : Math.ceil((new Date(booking.checkOutDate) - new Date(booking.checkInDate)) / (1000 * 60 * 60 * 24));
          
          // Try to get room price from various sources
          let roomPrice = 0;
          
          // Priority 1: From assigned room
          if (booking.room?.pricePerNight) {
            roomPrice = Number(booking.room.pricePerNight);
            console.log(`üîµ [renderBookings] Found price from booking.room.pricePerNight: ${roomPrice}`);
          } else if (booking.room?.roomTypeNavigation?.pricePerNight) {
            roomPrice = Number(booking.room.roomTypeNavigation.pricePerNight);
            console.log(`üîµ [renderBookings] Found price from booking.room.roomTypeNavigation.pricePerNight: ${roomPrice}`);
          }
          // Priority 2: From booking directly
          else if (booking.pricePerNight) {
            roomPrice = Number(booking.pricePerNight);
            console.log(`üîµ [renderBookings] Found price from booking.pricePerNight: ${roomPrice}`);
          } else if (booking.roomPrice) {
            roomPrice = Number(booking.roomPrice);
            console.log(`üîµ [renderBookings] Found price from booking.roomPrice: ${roomPrice}`);
          }
          // Priority 3: From requestedRoomType using room types cache
          else if (booking.requestedRoomType && window._roomTypesCache && Array.isArray(window._roomTypesCache)) {
            const roomType = window._roomTypesCache.find(rt => 
              rt.typeName?.toLowerCase() === booking.requestedRoomType?.toLowerCase() ||
              rt.roomTypeName?.toLowerCase() === booking.requestedRoomType?.toLowerCase() ||
              String(rt.roomTypeId) === String(booking.roomTypeId)
            );
            if (roomType?.pricePerNight) {
              roomPrice = Number(roomType.pricePerNight);
              console.log(`üîµ [renderBookings] Found price from room types cache (${booking.requestedRoomType}): ${roomPrice}`);
            }
          }
          // Priority 4: Try to get from roomTypeId if available
          else if (booking.roomTypeId && window._roomTypesCache && Array.isArray(window._roomTypesCache)) {
            const roomType = window._roomTypesCache.find(rt => String(rt.roomTypeId) === String(booking.roomTypeId));
            if (roomType?.pricePerNight) {
              roomPrice = Number(roomType.pricePerNight);
              console.log(`üîµ [renderBookings] Found price from roomTypeId (${booking.roomTypeId}): ${roomPrice}`);
            }
          }
          
          if (nightsNum > 0 && roomPrice > 0) {
            amount = nightsNum * roomPrice;
            // Update booking object for future use
            booking.estimatedTotalAmount = amount;
            console.log(`‚úÖ [renderBookings] Calculated amount for booking ${booking.bookingId}: ${vnd(amount)} (${nightsNum} nights √ó ${vnd(roomPrice)})`);
          } else {
            console.warn(`‚ö†Ô∏è [renderBookings] Cannot calculate amount for booking ${booking.bookingId}: nights=${nightsNum}, roomPrice=${roomPrice}, requestedRoomType=${booking.requestedRoomType}`);
            // If still 0, fetch booking detail synchronously before rendering
            // This ensures amount is available when card is rendered
            if (booking.bookingId) {
              // Fetch immediately and wait for result (for first render)
              fetchBookingDetailForAmountSync(booking.bookingId, booking).then(calculatedAmount => {
                if (calculatedAmount > 0) {
                  amount = calculatedAmount;
                  booking.estimatedTotalAmount = calculatedAmount;
                  // Re-render just this booking card
                  updateBookingCardAmount(booking.bookingId, calculatedAmount);
                }
              }).catch(e => {
                console.error(`‚ùå [renderBookings] Error fetching detail for ${booking.bookingId}:`, e);
              });
            }
          }
        } else if (amount <= 0) {
          // If no dates or amount is 0, fetch booking detail immediately
          console.warn(`‚ö†Ô∏è [renderBookings] Amount is 0 for booking ${booking.bookingId}, fetching detail synchronously`);
          if (booking.bookingId) {
            fetchBookingDetailForAmountSync(booking.bookingId, booking).then(calculatedAmount => {
              if (calculatedAmount > 0) {
                amount = calculatedAmount;
                booking.estimatedTotalAmount = calculatedAmount;
                // Re-render just this booking card
                updateBookingCardAmount(booking.bookingId, calculatedAmount);
              }
            }).catch(e => {
              console.error(`‚ùå [renderBookings] Error fetching detail for ${booking.bookingId}:`, e);
            });
          }
        }
        
        return `
          <div class="booking-card" style="animation-delay:${0.1 * idx}s">
            <div class="booking-header">
              <div>
                <div class="booking-code">#${booking.bookingCode || booking.bookingId}</div>
                <small class="text-muted">ƒê·∫∑t ng√†y: ${bookingDate}</small>
              </div>
              <span class="booking-status ${getStatusClass(booking.status)}">${getStatusText(booking.status)}</span>
            </div>
            
            <div class="booking-details">
              <div class="detail-item">
                <div class="detail-label">üìÖ Ng√†y nh·∫≠n</div>
                <div class="detail-value">${checkin}</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">üìÖ Ng√†y tr·∫£</div>
                <div class="detail-value">${checkout}</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">üåô S·ªë ƒë√™m</div>
                <div class="detail-value">${nights}</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">üë• S·ªë kh√°ch</div>
                <div class="detail-value">${booking.numberOfGuests || '-'} kh√°ch</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">üè® Ph√≤ng</div>
                <div class="detail-value">${booking.room?.roomNumber || booking.roomNumber || booking.requestedRoomType || '-'}</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">üí∞ T·ªïng ti·ªÅn</div>
                <div class="detail-value text-primary">${vnd(amount)}</div>
              </div>
            </div>
            
            ${specialBlock}
            
            <div class="booking-actions">
              ${canPayBooking(booking) ? `
                <button class=\"btn btn-outline-danger\" onclick=\"cancelBooking(${booking.bookingId})\">H·ªßy ƒë·∫∑t ph√≤ng</button>
                <button class=\"btn btn-primary\" onclick=\"openSimplePayment(${booking.bookingId})\">
                  <span class=\"oi oi-credit-card mr-2\"></span>Thanh to√°n
                </button>
              ` : booking.status === 'Pending' || booking.status === 'Confirmed' ? `
                <button class=\"btn btn-outline-danger\" onclick=\"cancelBooking(${booking.bookingId})\">H·ªßy ƒë·∫∑t ph√≤ng</button>
              ` : ''}
              ${(booking.status === 'CheckedOut' || 
                 (booking.status === 'Paid' && booking.checkOutDate && new Date(booking.checkOutDate) <= new Date()) ||
                 (booking.status === 'Confirmed' && booking.checkOutDate && new Date(booking.checkOutDate) <= new Date(Date.now() - 24*60*60*1000))
                ) && booking.roomId ? `
                <button class=\"btn btn-success\" onclick=\"reviewRoom(${booking.roomId}, ${booking.bookingId})\">
                  <span class=\"oi oi-star mr-2\"></span>ƒê√°nh gi√° ph√≤ng
                </button>
              ` : ''}
              ${booking.status === 'Paid' && booking.invoice ? `
                <div class=\"payment-info\">
                  <div class=\"payment-info-item\">
                    <span class=\"payment-info-label\">üí∞ Th·ªùi gian thanh to√°n:</span>
                    <span class=\"payment-info-value\">${formatPaymentDate(booking.invoice.paidDate || booking.updatedAt)}</span>
                  </div>
                  <div class=\"payment-info-item\">
                    <span class=\"payment-info-label\">üìÑ S·ªë giao d·ªãch:</span>
                    <span class=\"payment-info-value\">${booking.invoice.invoiceNumber || booking.bookingCode}</span>
                  </div>
                </div>
              ` : ''}
              <button class="btn btn-outline-secondary" onclick="viewBookingDetails(${booking.bookingId})">Xem chi ti·∫øt</button>
            </div>
          </div>
        `;
      }).join('');
    }

    async function cancelBooking(bookingId) {
      const ok = await showConfirm('H·ªßy ƒë·∫∑t ph√≤ng', 'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën h·ªßy ƒë·∫∑t ph√≤ng n√†y?', 'H·ªßy', 'Kh√¥ng');
      if (!ok) return;
      
      try {
        showPageLoading('ƒêang h·ªßy ƒë·∫∑t ph√≤ng...');
        const token = localStorage.getItem('token');
        const resp = await fetch(`${location.origin}/api/bookings/${bookingId}/cancel`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({reason: 'Kh√°ch h√†ng h·ªßy qua website'})
        });
        
        if (!resp.ok) {
          const error = await resp.json().catch(() => ({message: 'L·ªói h·ªßy ƒë·∫∑t ph√≤ng'}));
          throw new Error(error.message || 'L·ªói h·ªßy ƒë·∫∑t ph√≤ng');
        }
        
        showToast('H·ªßy ƒë·∫∑t ph√≤ng th√†nh c√¥ng', 'success');
        loadBookings();
      } catch(e) {
        showToast('L·ªói: ' + e.message, 'danger');
      } finally {
        hidePageLoading();
      }
    }

    function viewBookingDetails(bookingId) {
      window.location.href = `booking-details.html?id=${bookingId}`;
    }

    function reviewRoom(roomId, bookingId) {
      // Redirect to reviews page with room pre-selected
      window.location.href = `reviews.html?roomId=${roomId}&bookingId=${bookingId}`;
    }

    // Old payment system - removed, using simple-payment.js instead
    // let payingId = null;
    // let plModal = null;
    // let paymentWebSocketManager = null;

    // Old initPaymentModal function - removed, using simplePaymentModal instead
    // function initPaymentModal() { ... }

    // ƒê·ªãnh nghƒ©a h√†m payBooking ·ªü global scope ƒë·ªÉ onclick c√≥ th·ªÉ g·ªçi ƒë∆∞·ª£c
    window.payBooking = async function(bookingId){
      console.log('üîµ [payBooking] Called with bookingId:', bookingId);
      
      try {
        // Old payment system - redirect to simple payment
        // Using openSimplePayment instead
        console.log('‚ö†Ô∏è [payBooking] Old payBooking called, redirecting to openSimplePayment');
        if (typeof openSimplePayment === 'function') {
          openSimplePayment(bookingId);
          return;
        } else {
          showToast('H·ªá th·ªëng thanh to√°n ƒëang ƒë∆∞·ª£c c·∫≠p nh·∫≠t, vui l√≤ng th·ª≠ l·∫°i sau', 'warning');
          return;
        }
        
        /* OLD CODE - Commented out
        // ƒê·∫£m b·∫£o modal ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o
        if (!plModal) {
          initPaymentModal();
          if (!plModal) {
            showToast('H·ªá th·ªëng ƒëang kh·ªüi t·∫°o, vui l√≤ng th·ª≠ l·∫°i sau', 'warning');
            return;
          }
        }
        */

        payingId = bookingId;
        const bList = window._bookings || [];
        const b = bList.find(x => String(x.bookingId) === String(bookingId));
        
        console.log('üîµ [payBooking] Booking found:', b);
        
        // Validation
        if (!b) {
          console.error('‚ùå [payBooking] No booking found');
          showToast('Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒë·∫∑t ph√≤ng', 'danger');
          return;
        }
        
        console.log('üîµ [payBooking] Checking if can pay...');
        console.log('üîµ [payBooking] Booking status:', b.status);
        const canPay = canPayBooking(b);
        console.log('üîµ [payBooking] canPayBooking result:', canPay);
        if (!canPay) {
          console.warn('‚ö†Ô∏è [payBooking] Cannot pay booking - status:', b.status);
          showToast('ƒê·∫∑t ph√≤ng n√†y kh√¥ng th·ªÉ thanh to√°n. Vui l√≤ng ki·ªÉm tra tr·∫°ng th√°i.', 'warning');
          return;
        }
        
        console.log('üîµ [payBooking] Getting amount...');
        console.log('üîµ [payBooking] estimatedTotalAmount:', b?.estimatedTotalAmount);
        console.log('üîµ [payBooking] totalAmount:', b?.totalAmount);
        console.log('üîµ [payBooking] Full booking object:', JSON.stringify(b, null, 2));
        
        // Try to get amount from various fields
        let amount = Number(b?.estimatedTotalAmount ?? b?.totalAmount ?? b?.amount ?? b?.totalPrice ?? 0);
        
        // Trust backend amount - Database ƒë√£ ƒë∆∞·ª£c s·ª≠a v·ªÅ gi√° ƒë√∫ng (5,000 VND)
        // Kh√¥ng c·∫ßn correction n·ªØa
        console.log('‚úÖ [payBooking] Using amount from backend:', amount);
        
        // If amount is 0 or invalid, try to calculate from dates and room price
        if (amount <= 0 && b?.checkInDate && b?.checkOutDate) {
          console.log('üîµ [payBooking] Amount is 0, trying to calculate from dates...');
          const checkin = new Date(b.checkInDate);
          const checkout = new Date(b.checkOutDate);
          const nights = Math.ceil((checkout - checkin) / (1000 * 60 * 60 * 24));
          console.log('üîµ [payBooking] Nights calculated:', nights);
          
          // Try to get room price from booking or fetch booking detail
          const roomPrice = Number(b?.roomPrice ?? b?.pricePerNight ?? b?.room?.pricePerNight ?? b?.roomTypeNavigation?.pricePerNight ?? 0);
          console.log('üîµ [payBooking] Room price:', roomPrice);
          
          if (nights > 0 && roomPrice > 0) {
            amount = nights * roomPrice;
            console.log('‚úÖ [payBooking] Calculated amount from nights * price:', amount);
          }
        }
        
        // If still 0, fetch booking detail from API with Room included
        if (amount <= 0) {
          console.log('üîµ [payBooking] Amount still 0, fetching booking detail from API...');
          try {
            const token = localStorage.getItem('token');
            const detailUrl = `${location.origin}/api/bookings/${bookingId}?_=${Date.now()}`;
            const detailResp = await fetch(detailUrl, {
              cache: 'no-store',
              headers: {
                'Authorization': `Bearer ${token}`
              }
            });
            
            if (detailResp.ok) {
              const bookingDetail = await detailResp.json();
              console.log('‚úÖ [payBooking] Booking detail fetched:', bookingDetail);
              amount = Number(bookingDetail?.estimatedTotalAmount ?? bookingDetail?.totalAmount ?? bookingDetail?.amount ?? 0);
              
              // Trust backend amount - Database ƒë√£ ƒë∆∞·ª£c s·ª≠a v·ªÅ gi√° ƒë√∫ng (5,000 VND)
              // Kh√¥ng c·∫ßn correction n·ªØa
              console.log('‚úÖ [payBooking] Amount from API:', amount);
              
              // If still 0, try to calculate from Room
              if (amount <= 0 && bookingDetail?.checkInDate && bookingDetail?.checkOutDate) {
                const checkin = new Date(bookingDetail.checkInDate);
                const checkout = new Date(bookingDetail.checkOutDate);
                const nights = Math.ceil((checkout - checkin) / (1000 * 60 * 60 * 24));
                console.log('üîµ [payBooking] Nights from detail:', nights);
                
                // Try multiple ways to get room price
                let roomPrice = 0;
                if (bookingDetail?.room?.pricePerNight) {
                  roomPrice = Number(bookingDetail.room.pricePerNight);
                  console.log('‚úÖ [payBooking] Room price from room.pricePerNight:', roomPrice);
                } else if (bookingDetail?.room?.roomTypeNavigation?.pricePerNight) {
                  roomPrice = Number(bookingDetail.room.roomTypeNavigation.pricePerNight);
                  console.log('‚úÖ [payBooking] Room price from roomTypeNavigation.pricePerNight:', roomPrice);
                } else if (bookingDetail?.pricePerNight) {
                  roomPrice = Number(bookingDetail.pricePerNight);
                  console.log('‚úÖ [payBooking] Room price from bookingDetail.pricePerNight:', roomPrice);
                } else {
                  // Try to fetch room by RequestedRoomType
                  console.log('üîµ [payBooking] No room price found, trying to fetch by requestedRoomType...');
                  const requestedType = bookingDetail?.requestedRoomType || b?.requestedRoomType;
                  if (requestedType) {
                    try {
                      const roomsResp = await fetch(`${location.origin}/api/rooms?roomTypeId=${bookingDetail?.roomTypeId || ''}&_=${Date.now()}`, {cache: 'no-store'});
                      if (roomsResp.ok) {
                        const rooms = await roomsResp.json();
                        const matchingRoom = Array.isArray(rooms) ? rooms.find(r => 
                          r.roomTypeName === requestedType || 
                          r.roomType === requestedType ||
                          r.typeName === requestedType
                        ) : null;
                        if (matchingRoom?.pricePerNight) {
                          roomPrice = Number(matchingRoom.pricePerNight);
                          console.log('‚úÖ [payBooking] Room price from API search:', roomPrice);
                        }
                      }
                    } catch(e) {
                      console.error('‚ùå [payBooking] Error fetching rooms:', e);
                    }
                  }
                }
                
                if (nights > 0 && roomPrice > 0) {
                  amount = nights * roomPrice;
                  console.log('‚úÖ [payBooking] Calculated amount from nights * price:', amount, `(${nights} nights √ó ${roomPrice} VND)`);
                } else {
                  console.warn('‚ö†Ô∏è [payBooking] Cannot calculate: nights=', nights, 'roomPrice=', roomPrice);
                }
              }
              
              // Update booking object
              if (amount > 0) {
                b.estimatedTotalAmount = amount;
                console.log('‚úÖ [payBooking] Updated booking object with amount');
              }
            } else {
              console.error('‚ùå [payBooking] Failed to fetch booking detail:', detailResp.status, detailResp.statusText);
            }
          } catch(e) {
            console.error('‚ùå [payBooking] Error fetching booking detail:', e);
          }
        }
        
        console.log('üîµ [payBooking] Final calculated amount:', amount);
        if (amount <= 0) {
          console.error('‚ùå [payBooking] Invalid amount after all attempts:', amount);
          showToast('Kh√¥ng th·ªÉ x√°c ƒë·ªãnh s·ªë ti·ªÅn thanh to√°n. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n.', 'danger');
          return;
        }
        console.log('‚úÖ [payBooking] Validation passed, amount:', amount);
        
        // Update booking object with corrected amount
        if (b) {
          b.estimatedTotalAmount = amount;
          console.log('‚úÖ [payBooking] Updated booking object with corrected amount:', amount);
        }
        
        const bookingCode = b.bookingCode || `BKG${bookingId}`;
        const info = `BOOKING-${bookingId}`;
        
        // CRITICAL: Ensure amount is not multiplied by 100
        // VietQR expects amount in VND (e.g., 5000 for 5,000 VND, NOT 500000)
        const qrAmount = Math.round(amount); // Ensure integer, no decimals
        console.log('üí∞ [payBooking] Final amount for QR:', qrAmount, 'VND (formatted:', vnd(qrAmount), ')');
        console.log('üí∞ [payBooking] Amount breakdown:', {
          original: amount,
          rounded: qrAmount,
          formatted: vnd(qrAmount),
          bookingId: bookingId
        });
        
        // Add cache buster to force QR regeneration
        const cacheBuster = `&_t=${Date.now()}`;
        // VietQR format: https://img.vietqr.io/image/{BANK_CODE}-{ACCOUNT}-compact.png?amount={amount}&addInfo={info}&accountName={name}
        // Th·ª≠ format kh√¥ng encode ph·∫ßn ƒë·∫ßu ƒë·ªÉ tr√°nh double encoding
        const imgUrl = `https://img.vietqr.io/image/${BANK_CODE}-${BANK_ACCOUNT}-compact.png?amount=${qrAmount}&addInfo=${encodeURIComponent(info)}&accountName=${encodeURIComponent(BANK_ACCOUNT_NAME)}${cacheBuster}`;
        console.log('üîó [payBooking] QR URL (with cache buster):', imgUrl);
        
        console.log('üîµ [payBooking] Updating modal content...');
        console.log('üîµ [payBooking] Amount:', amount);
        console.log('üîµ [payBooking] Booking Code:', bookingCode);
        console.log('üîµ [payBooking] QR Image URL:', imgUrl);
        
        // Update modal content
        const el2 = document.getElementById('plCode2');
        if (el2) {
          el2.textContent = bookingCode;
          console.log('‚úÖ [payBooking] Booking code updated');
        } else {
          console.warn('‚ö†Ô∏è [payBooking] plCode2 element not found');
        }
        
        const amountEl = document.getElementById('plAmount');
        if (amountEl) {
          amountEl.textContent = vnd(amount);
          console.log('‚úÖ [payBooking] Amount updated:', vnd(amount));
        }
        
        const bankNameEl = document.getElementById('plBankName');
        if (bankNameEl) bankNameEl.textContent = 'MBBank';
        
        const bankAccEl = document.getElementById('plBankAcc');
        if (bankAccEl) bankAccEl.textContent = BANK_ACCOUNT;
        
        const bankAccNameEl = document.getElementById('plBankAccName');
        if (bankAccNameEl) bankAccNameEl.textContent = BANK_ACCOUNT_NAME;
        
        // Update QR image - simplified approach
        const imgEl = document.getElementById('plVqrImg');
        if (imgEl) {
          // Set basic styles
          imgEl.style.display = 'block';
          imgEl.style.visibility = 'visible';
          imgEl.style.maxWidth = '100%';
          imgEl.alt = `VietQR - ${bookingCode}`;
          
          // Clear previous error handlers
          imgEl.onload = null;
          imgEl.onerror = null;
          
          // Set QR image URL with cache buster
          imgEl.src = imgUrl;
          
          // Simple error handler
          imgEl.onerror = () => {
            console.warn('‚ö†Ô∏è [payBooking] QR Image failed to load, trying fallback URL');
            // Fallback: try without encoding account name
            const fallbackUrl = `https://img.vietqr.io/image/${BANK_CODE}-${BANK_ACCOUNT}-compact.png?amount=${qrAmount}&addInfo=${encodeURIComponent(info)}&accountName=${BANK_ACCOUNT_NAME}${cacheBuster}`;
            imgEl.src = fallbackUrl;
          };
          
          imgEl.onload = () => {
            console.log('‚úÖ [payBooking] QR Image loaded successfully');
          };
        }
        
        // Check if booking is already Paid before showing payment modal
        if (b.status === 'Paid') {
          showToast('ƒê·∫∑t ph√≤ng n√†y ƒë√£ ƒë∆∞·ª£c thanh to√°n!', 'success');
          return;
        }
        
        // Set default payment method to BankTransfer (QR) and ensure QR section is visible
        const paymentMethodSelect = document.getElementById('plPaymentMethod');
        if (paymentMethodSelect) {
          paymentMethodSelect.value = 'BankTransfer';
          // Trigger change event to show QR immediately
          paymentMethodSelect.dispatchEvent(new Event('change'));
        } else {
          // Fallback: ensure QR section is visible
          const bankSection = document.getElementById('plBankSection');
          if (bankSection) bankSection.style.display = 'block';
          const cashSection = document.getElementById('plCashSection');
          if (cashSection) cashSection.style.display = 'none';
        }
        
        /* OLD CODE - Commented out (using simplePaymentModal instead)
        console.log('üîµ [payBooking] Showing modal...');
        plModal.show();
        console.log('‚úÖ [payBooking] Modal shown with QR code');
        */
        
        // Hi·ªÉn th·ªã n√∫t Test Payment n·∫øu localhost ho·∫∑c development
        const testBtn = document.getElementById('plTestPaymentBtn');
        if (testBtn) {
          const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
          testBtn.style.display = isLocalhost ? 'block' : 'none';
          testBtn.setAttribute('data-booking-id', bookingId);
        }
        
        // T·∫°o payment session v√† k·∫øt n·ªëi WebSocket
        await startPaymentWebSocket(bookingId, amount);
      } catch(e) {
        console.error('‚ùå [payBooking] Error:', e);
        showToast('L·ªói khi m·ªü form thanh to√°n: ' + e.message, 'danger');
      }
    };

    // Handle payment method change - show QR immediately when QR is selected
    const plPaymentMethodSelect = document.getElementById('plPaymentMethod');
    if (plPaymentMethodSelect) {
      plPaymentMethodSelect.addEventListener('change', function() {
        const method = this.value;
        const bankSection = document.getElementById('plBankSection');
        const cashSection = document.getElementById('plCashSection');
        
        console.log('üîµ [PaymentMethod] Changed to:', method);
        
        if (method === 'BankTransfer') {
          // Show QR section
          if (bankSection) bankSection.style.display = 'block';
          if (cashSection) cashSection.style.display = 'none';
          
          // If we have booking data, show QR immediately
          if (payingId) {
            const bList = window._bookings || [];
            const b = bList.find(x => String(x.bookingId) === String(payingId));
            if (b) {
              // Calculate amount if needed
              let amount = Number(b?.estimatedTotalAmount ?? b?.totalAmount ?? 0);
              if (amount <= 0 && b.checkInDate && b.checkOutDate) {
                const nights = Math.ceil((new Date(b.checkOutDate) - new Date(b.checkInDate)) / (1000 * 60 * 60 * 24));
                const roomPrice = Number(b?.room?.pricePerNight ?? b?.pricePerNight ?? 0);
                if (nights > 0 && roomPrice > 0) {
                  amount = nights * roomPrice;
                }
              }
              
              // Trust backend amount - Database ƒë√£ ƒë∆∞·ª£c s·ª≠a v·ªÅ gi√° ƒë√∫ng (5,000 VND)
              // Kh√¥ng c·∫ßn correction n·ªØa
              console.log('‚úÖ [PaymentMethod] Using amount from backend:', amount);
              
              if (amount > 0) {
                const bookingCode = b.bookingCode || `BKG${payingId}`;
                const info = `BOOKING-${payingId}`;
                const qrAmount = Math.round(amount);
                const cacheBuster = `&_t=${Date.now()}`;
                const imgUrl = `https://img.vietqr.io/image/${BANK_CODE}-${BANK_ACCOUNT}-compact.png?amount=${qrAmount}&addInfo=${encodeURIComponent(info)}&accountName=${encodeURIComponent(BANK_ACCOUNT_NAME)}${cacheBuster}`;
                
                const imgEl = document.getElementById('plVqrImg');
                if (imgEl) {
                  imgEl.style.display = 'block';
                  imgEl.src = imgUrl;
                }
              }
            }
          }
        } else if (method === 'Cash') {
          // Show cash section
          if (bankSection) bankSection.style.display = 'none';
          if (cashSection) cashSection.style.display = 'block';
        }
      });
    }
    
    // Copy payment content helper (if button exists)
    (document.getElementById('plCopyBtn')||{addEventListener:()=>{}}).addEventListener('click', async ()=>{
      try{
        const text = `BOOKING-${payingId}`;
        await navigator.clipboard.writeText(text);
        const msg = document.getElementById('plCopyMsg');
        if(msg){ msg.style.display = 'inline'; setTimeout(()=>msg.style.display='none', 1500); }
      }catch(_){ /* ignore */ }
    });

    // Polling interval ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i thanh to√°n t·ª± ƒë·ªông
    // paymentPollingInterval is defined in simple-payment.js
    
    // H√†m ki·ªÉm tra tr·∫°ng th√°i booking (tr·∫£ v·ªÅ full booking object)
    async function checkBookingPaymentStatus(bookingId) {
      try {
        const token = localStorage.getItem('token');
        if (!token) {
          console.warn('‚ö†Ô∏è [checkBookingPaymentStatus] No token found');
          return null;
        }
        
        const url = `${location.origin}/api/bookings/${bookingId}?_=${Date.now()}`;
        const resp = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${token}`
          },
          cache: 'no-store'
        });
        
        if (!resp.ok) {
          if (resp.status === 401) {
            console.warn('‚ö†Ô∏è [checkBookingPaymentStatus] Token expired or invalid');
            // C√≥ th·ªÉ redirect v·ªÅ login
            return null;
          }
          return null;
        }
        
        const booking = await resp.json();
        return booking?.status || null; // Tr·∫£ v·ªÅ status string
      } catch(e) {
        console.error('‚ùå [checkBookingPaymentStatus] Error:', e);
        return null;
      }
    }
    
    /**
     * B·∫Øt ƒë·∫ßu WebSocket connection cho payment
     */
    async function startPaymentWebSocket(bookingId, amount) {
      try {
        // Disconnect old connection if any
        if (paymentWebSocketManager) {
          paymentWebSocketManager.disconnect();
        }

        // T·∫°o WebSocket manager m·ªõi
        paymentWebSocketManager = new PaymentWebSocketManager();

        // Hi·ªÉn th·ªã loading states
        const waitingMsg = document.getElementById('plWaitingMessage');
        const waitingText = document.getElementById('plWaitingText');
        const timerEl = document.getElementById('plTimer');
        
        if (waitingMsg) waitingMsg.style.display = 'block';
        if (waitingText) waitingText.textContent = 'ƒêang k·∫øt n·ªëi...';
        if (timerEl) timerEl.style.display = 'block';

        // T·∫°o session v√† k·∫øt n·ªëi
        const sessionId = await paymentWebSocketManager.createSessionAndConnect(
          bookingId,
          amount,
          // onStatusChange callback
          async (data) => {
            console.log('üì® [PaymentStatus] Status changed:', data);
            handlePaymentStatusChange(data, bookingId);
          },
          // onError callback
          (error) => {
            console.error('‚ùå [PaymentWebSocket] Error:', error);
            // N·∫øu l·ªói 401, c√≥ th·ªÉ token h·∫øt h·∫°n
            if (error.message && error.message.includes('Unauthorized')) {
              showToast('Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.', 'warning');
            } else {
              showToast('L·ªói k·∫øt n·ªëi: ' + error.message, 'danger');
            }
            // Fallback to polling
            startPaymentPolling(bookingId);
          }
        );

        if (waitingText) waitingText.textContent = 'ƒêang ch·ªù thanh to√°n...';
        console.log('‚úÖ [PaymentWebSocket] Started for session:', sessionId);
        
        // Join booking group as fallback (n·∫øu WebSocket ƒë√£ k·∫øt n·ªëi)
        if (paymentWebSocketManager && paymentWebSocketManager.connection) {
          try {
            await paymentWebSocketManager.connection.invoke('JoinBookingGroup', bookingId);
            console.log('‚úÖ [PaymentWebSocket] Joined booking group:', bookingId);
          } catch (e) {
            console.warn('‚ö†Ô∏è [PaymentWebSocket] Could not join booking group:', e);
          }
        }
        
        // B·∫Øt ƒë·∫ßu polling nh∆∞ m·ªôt backup ƒë·ªÉ check booking status tr·ª±c ti·∫øp
        // (v√¨ VietQR kh√¥ng c√≥ webhook t·ª± ƒë·ªông)
        startPaymentPolling(bookingId);

      } catch (error) {
        console.error('‚ùå [PaymentWebSocket] Failed to start:', error);
        // N·∫øu l·ªói 401, c√≥ th·ªÉ token h·∫øt h·∫°n
        if (error.message && error.message.includes('Unauthorized')) {
          showToast('Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.', 'warning');
        } else {
          showToast('L·ªói kh·ªüi t·∫°o thanh to√°n: ' + error.message, 'danger');
        }
        // Fallback to polling
        startPaymentPolling(bookingId);
      }
    }

    /**
     * X·ª≠ l√Ω khi payment th√†nh c√¥ng (d√πng chung cho c·∫£ SignalR v√† polling)
     */
    function handlePaymentSuccess(bookingId) {
      const waitingMsg = document.getElementById('plWaitingMessage');
      const paidMsg = document.getElementById('plPaidMessage');
      const failedMsg = document.getElementById('plFailedMessage');
      const expiredMsg = document.getElementById('plExpiredMessage');
      const timerEl = document.getElementById('plTimer');
      const qrImg = document.getElementById('plVqrImg');
      const bankSection = document.getElementById('plBankSection');
      
      // ·∫®n t·∫•t c·∫£ messages v√† elements kh√°c
      if (waitingMsg) waitingMsg.style.display = 'none';
      if (failedMsg) failedMsg.style.display = 'none';
      if (expiredMsg) expiredMsg.style.display = 'none';
      if (timerEl) timerEl.style.display = 'none';
      
      // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
      if (paidMsg) {
        paidMsg.style.display = 'block';
        const paidText = paidMsg.querySelector('.text-success') || paidMsg;
        if (paidText) {
          paidText.textContent = '‚úÖ Thanh to√°n th√†nh c√¥ng!';
        }
      }
      
      // ·∫®n QR code v√† bank section
      if (qrImg) {
        qrImg.style.display = 'none';
      }
      if (bankSection) {
        bankSection.style.display = 'none';
      }
      
      // Hi·ªÉn th·ªã toast v√† ƒë√≥ng modal sau 2 gi√¢y
      showToast('‚úÖ Thanh to√°n th√†nh c√¥ng! Tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.', 'success');
      
      setTimeout(() => {
        // Using simplePaymentModal instead
        const modal = bootstrap.Modal.getInstance(document.getElementById('simplePaymentModal'));
        if (modal) modal.hide();
        loadBookings();
      }, 2000);
      
      // Clear polling booking ID
      currentPollingBookingId = null;
    }

    /**
     * X·ª≠ l√Ω khi payment status thay ƒë·ªïi
     */
    async function handlePaymentStatusChange(data, bookingId) {
      const status = data.status?.toLowerCase();
      const waitingMsg = document.getElementById('plWaitingMessage');
      const paidMsg = document.getElementById('plPaidMessage');
      const failedMsg = document.getElementById('plFailedMessage');
      const expiredMsg = document.getElementById('plExpiredMessage');
      const timerEl = document.getElementById('plTimer');
      const qrImg = document.getElementById('plVqrImg');

      // ·∫®n t·∫•t c·∫£ messages
      if (waitingMsg) waitingMsg.style.display = 'none';
      if (paidMsg) paidMsg.style.display = 'none';
      if (failedMsg) failedMsg.style.display = 'none';
      if (expiredMsg) expiredMsg.style.display = 'none';
      if (timerEl) timerEl.style.display = 'none';

      if (status === 'paid') {
        // Thanh to√°n th√†nh c√¥ng - d√πng h√†m chung
        handlePaymentSuccess(bookingId);

      } else if (status === 'failed') {
        // Thanh to√°n th·∫•t b·∫°i
        if (failedMsg) {
          failedMsg.style.display = 'block';
          failedMsg.textContent = `‚ùå Thanh to√°n th·∫•t b·∫°i${data.errorMessage ? ': ' + data.errorMessage : ''}`;
        }
        if (qrImg) qrImg.style.display = 'none';
        showToast('‚ùå Thanh to√°n th·∫•t b·∫°i', 'danger');

      } else if (status === 'expired') {
        // QR h·∫øt h·∫°n
        if (expiredMsg) expiredMsg.style.display = 'block';
        if (qrImg) qrImg.style.display = 'none';
        showToast('‚è∞ QR ƒë√£ h·∫øt h·∫°n. Vui l√≤ng t·∫°o l·∫°i.', 'warning');

        // C√≥ th·ªÉ th√™m n√∫t "T·∫°o QR m·ªõi" ·ªü ƒë√¢y
        const timerValue = document.getElementById('plTimerValue');
        if (timerValue) timerValue.textContent = '00:00';

      } else if (status === 'cancelled') {
        // ƒê√£ h·ªßy
        if (expiredMsg) {
          expiredMsg.style.display = 'block';
          expiredMsg.textContent = '‚ùå ƒê√£ h·ªßy thanh to√°n';
        }
        if (qrImg) qrImg.style.display = 'none';
        showToast('ƒê√£ h·ªßy thanh to√°n', 'warning');
      }
    }

    // H√†m test payment (ch·ªâ d√πng cho development)
    async function testPayment() {
      const testBtn = document.getElementById('plTestPaymentBtn');
      const bookingId = testBtn ? parseInt(testBtn.getAttribute('data-booking-id') || '0') : 0;
      
      if (!bookingId) {
        showToast('Kh√¥ng t√¨m th·∫•y booking ID', 'warning');
        return;
      }
      
      const confirm = await showConfirm('Test Payment', 'B·∫°n c√≥ ch·∫Øc mu·ªën simulate thanh to√°n th√†nh c√¥ng cho booking n√†y?', 'X√°c nh·∫≠n', 'H·ªßy');
      if (!confirm) return;
      
      try {
        const token = localStorage.getItem('token');
        if (!token) {
          showToast('Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i', 'warning');
          return;
        }
        
        showToast('ƒêang x·ª≠ l√Ω test payment...', 'info');
        
        const resp = await fetch(`${location.origin}/api/payment/test/${bookingId}`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (!resp.ok) {
          const error = await resp.json().catch(() => ({ message: 'L·ªói test payment' }));
          throw new Error(error.message || 'L·ªói test payment');
        }
        
        const result = await resp.json();
        showToast('‚úÖ Test payment th√†nh c√¥ng! ƒêang c·∫≠p nh·∫≠t...', 'success');
        
        // Polling s·∫Ω t·ª± ƒë·ªông detect status = "Paid" v√† update UI
        // Ho·∫∑c ƒë·ª£i m·ªôt ch√∫t r·ªìi reload
        setTimeout(() => {
          loadBookings();
        }, 1000);
        
      } catch(e) {
        console.error('‚ùå [testPayment] Error:', e);
        showToast('L·ªói: ' + e.message, 'danger');
      }
    }
    
    // Fallback: B·∫Øt ƒë·∫ßu polling khi modal m·ªü (n·∫øu WebSocket kh√¥ng kh·∫£ d·ª•ng)
    // L∆∞u bookingId ƒëang ƒë∆∞·ª£c poll ƒë·ªÉ c√≥ th·ªÉ check l·∫°i sau
    let currentPollingBookingId = null;
    
    function startPaymentPolling(bookingId) {
      // D·ª´ng polling c≈© n·∫øu c√≥ (using simple-payment.js)
      if (window.paymentPollingInterval) {
        clearInterval(window.paymentPollingInterval);
        window.paymentPollingInterval = null;
      }
      
      currentPollingBookingId = bookingId;
      console.log('üîÑ [startPaymentPolling] Starting payment polling for booking:', bookingId);
      
      // Hi·ªÉn th·ªã th√¥ng b√°o ƒëang ch·ªù
      const waitingMsg = document.getElementById('plWaitingMessage');
      const paidMsg = document.getElementById('plPaidMessage');
      if (waitingMsg) waitingMsg.style.display = 'block';
      if (paidMsg) paidMsg.style.display = 'none';
      
      // B·∫Øt ƒë·∫ßu polling m·ªói 3 gi√¢y (tƒÉng frequency ƒë·ªÉ detect nhanh h∆°n)
      window.paymentPollingInterval = setInterval(async () => {
        const status = await checkBookingPaymentStatus(bookingId);
        console.log('üîç [PaymentPolling] Current status:', status, 'for booking:', bookingId);
        
        if (status === 'Paid') {
          console.log('‚úÖ [PaymentPolling] Payment detected! Stopping polling and updating UI...');
          
          // D·ª´ng polling
          if (window.paymentPollingInterval) {
            clearInterval(window.paymentPollingInterval);
            window.paymentPollingInterval = null;
          }
          
          // D·ª´ng WebSocket n·∫øu c√≥
          if (paymentWebSocketManager) {
            paymentWebSocketManager.disconnect();
            paymentWebSocketManager = null;
          }
          
          // ·∫®n t·∫•t c·∫£ messages tr∆∞·ªõc
          if (waitingMsg) waitingMsg.style.display = 'none';
          const failedMsg = document.getElementById('plFailedMessage');
          const expiredMsg = document.getElementById('plExpiredMessage');
          const timerEl = document.getElementById('plTimer');
          if (failedMsg) failedMsg.style.display = 'none';
          if (expiredMsg) expiredMsg.style.display = 'none';
          if (timerEl) timerEl.style.display = 'none';
          
          // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
          if (paidMsg) {
            paidMsg.style.display = 'block';
            // C·∫≠p nh·∫≠t n·ªôi dung th√¥ng b√°o
            const paidText = paidMsg.querySelector('.text-success') || paidMsg;
            if (paidText) {
              paidText.textContent = '‚úÖ Thanh to√°n th√†nh c√¥ng!';
            }
          }
          
          // ·∫®n QR code v√† bank section
          const qrImg = document.getElementById('plVqrImg');
          const bankSection = document.getElementById('plBankSection');
          if (qrImg) {
            qrImg.style.display = 'none';
          }
          if (bankSection) {
            bankSection.style.display = 'none';
          }
          
          // Hi·ªÉn th·ªã th√¥ng b√°o v√† ƒë√≥ng modal sau 2 gi√¢y
          showToast('‚úÖ Thanh to√°n th√†nh c√¥ng! Tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.', 'success');
          
          setTimeout(() => {
            // Using simplePaymentModal instead
            const modal = bootstrap.Modal.getInstance(document.getElementById('simplePaymentModal'));
            if (modal) modal.hide();
            // Reload bookings ƒë·ªÉ hi·ªÉn th·ªã tr·∫°ng th√°i m·ªõi
            loadBookings();
          }, 2000);
        }
      }, 3000); // Ki·ªÉm tra m·ªói 3 gi√¢y
      
      // D·ª´ng polling sau 5 ph√∫t (300 gi√¢y) ƒë·ªÉ tr√°nh polling v√¥ h·∫°n
      setTimeout(() => {
        if (window.paymentPollingInterval) {
          console.log('‚è∞ [PaymentPolling] Timeout reached, stopping polling');
          clearInterval(window.paymentPollingInterval);
          window.paymentPollingInterval = null;
          if (waitingMsg) waitingMsg.style.display = 'none';
        }
      }, 300000); // 5 ph√∫t
    }
    
    // D·ª´ng WebSocket/Polling khi modal ƒë√≥ng
    const plModalElement = document.getElementById('payListModal');
    if (plModalElement) {
      plModalElement.addEventListener('hidden.bs.modal', () => {
        // Disconnect WebSocket
        if (paymentWebSocketManager) {
          console.log('üõë [PaymentWebSocket] Modal closed, disconnecting');
          paymentWebSocketManager.disconnect();
          paymentWebSocketManager = null;
        }
        
        // KH√îNG d·ª´ng polling khi modal ƒë√≥ng - ƒë·ªÉ ti·∫øp t·ª•c check trong background
        // Polling s·∫Ω t·ª± d·ª´ng khi booking ƒë√£ Paid ho·∫∑c timeout
        console.log('‚ÑπÔ∏è [PaymentPolling] Modal closed, but polling continues in background for booking:', currentPollingBookingId);
        
        // Reset UI
        const waitingMsg = document.getElementById('plWaitingMessage');
        const paidMsg = document.getElementById('plPaidMessage');
        const failedMsg = document.getElementById('plFailedMessage');
        const expiredMsg = document.getElementById('plExpiredMessage');
        const timerEl = document.getElementById('plTimer');
        
        if (waitingMsg) waitingMsg.style.display = 'none';
        if (paidMsg) paidMsg.style.display = 'none';
        if (failedMsg) failedMsg.style.display = 'none';
        if (expiredMsg) expiredMsg.style.display = 'none';
        if (timerEl) timerEl.style.display = 'none';
      });
    }


    loadBookings();
    // Auto-refresh d·ªØ li·ªáu m·ªói 10 gi√¢y ƒë·ªÉ detect payment nhanh h∆°n (gi·∫£m t·ª´ 60s xu·ªëng 10s)
    setInterval(() => {
      console.log('üîÑ [Auto-refresh] Reloading bookings...');
      loadBookings();
    }, 10000); // 10 gi√¢y thay v√¨ 60 gi√¢y ƒë·ªÉ detect payment nhanh h∆°n
  </script>
</body>
</html>

